# 리엑티브 스트림

## 리액티브 프로그래밍


### 서론

- 리액티브 프로그래밍은 종종 동시성 프로그래밍이나 고성능 처리 등과 떼어놓기 어려울 정도로 같이 언급되긴 하지만, 사실 이들은 **원론적으로 완전히 다르다.**

- 또 리액티브 프로그래밍은 함수형 반응형 프로그래밍 (Functional Reactive Programming, FRP)과 같이 언급되기도 하고 같은 것으로 여겨지기도 한다.

### 무엇인가

- 리액티브 프로그래밍은 지능정 라우팅과 이벤트 소비에 대한 그리고 이들 모두를 합쳐 행동을 변화시킨다는 마이크로 아키텍쳐 스타일이다.

- 리액티브 프로그래밍이 주는 반항은 마이크로서비스의 부흥 그리고 멀티코어 프로세서의 대중화와 (필연적으로) 동시에 이루어졌다.

```

리액티브 프로그래밍을 뒷반침하는 기본적인 개념은 어떤 값에 지속적으로 대응할 수 있는 어떤 데이터 타입들이 있다는 것이다.
이런 지속적으로 변화하는 값들과 연관된 연산 작업들은 연산 자체가 지속적으로 변화하는 값을 갖고 있게 된다.

```

- 함수형 반응형 프로그래밍 (FRP)은 고성능, 동시성 비동기 처리 그리고 넌블락킹 IO 등의 개념과 매우 친밀하다.

- **하지만, FRP가 그런 것들과 아무런 관계 없는 것이 아닌가라는 의심을 갖고 시작하는 것이 도움이 될 수 있다.**

- 분명히 리액티브 모델을 사용하면 그러한 고려사항들이 (종종 호출자의 입장에서는 당연스러울 정도로 자연스럽게 처리되기도 한다.

- 하지만 리액티브 프로그래밍의 진정한 혜택은 이러한 고려사항들을 효과적이고 효율적으로 처리할 수 있다는 점에서 전적으로 구현에 관련된 문제라고 생각할 수 있다.


### 리엑티브 사용 사례

#### 외부 서비스 호출 (External Service Call)

- 요즘의 많은 백앤드 서비스들은 REST 방식(즉, HTTP 기반으로 동작한다.)이며 그래서 기반 프로토콜은 기본적으로 **응답을 대기(Blocking)해야 하고 동기적(Synchronous)으로 수행된다.**

- 이런 서비스들은 또 다른 서비스들을 호출하도록 구현되며, 그래서 수많은 서비스들이 첫 번째 호출의 결과와 관련있기 때문이다.

- 수많은 입출력(IO)이 수행되는 과정에서, 만약 어떤 요청을 전송하기 전에 다른 호출이 완료되기를 기다려야 한다면, 서비스 사용자는 응답 데이터가 만들어지기도 전에 좌절하여 포기할 수도 있다.

- 그렇기 때문에 외부 서비스를 호출하는 경우, 특히 그 서비스호출들이 복잡하게 연결되어 있는 경우야 말로 최적화 하기 좋은 지점이 된다.

- 함수형 리액티브 프로그래밍 (FRP)은 이러한 동작들을 수행하는 로직을 조합할 수 있도록 보장하며 그래서 개발자들은 서비스 호출하는 코드를 쉽게 작성할 수 있다.

### 높은 동시성 메시지 소비자 (Highly Concurrent Message Consumers)

- 메시지 프로세싱은, 특히 고도의 동시 처리를 수행한다는 점에서 엔터프라이즈 어플리케이션에서 흔히 사용된다.

- 리액티브 프레임워크들은 마이크로 벤치마크를 측정하여 JVM 내에서 1초당 수없이 많은 메시지를 처리할 수 있는지 보여주기를 좋아한다

### Java 에서의 리액티브 프로그래밍

#### Reactive Stream

- Reactive Stream은 매우 낮은 수준의 계약으로, 몇 안되는 Java 인터페이스(와 Technology Compatibility Kit)로 표현되지만, 다른 언어에도 적용될 수 있다.

- 이 인터페이스들은 명시적인 배압(back pressure)과 함께 배포자(Publisher)와 구독자(Subscriber)를 위한 기본적인 빌딩 블럭을 표현하는데,

- 상호 정보교환을 하는 라이브러리들을 위한 일반적인 언어를 만든다. Reactive Stream은 JDK 버전 9의 java.util.concurrent.Flow에 통합되었다.


#### RxJava

- 넷플릭스는 꽤 오랜기간동안 리액티브 패턴을 사용해왔으며, 이후 Netflix/RxJava라는 도구를 오픈소스 라이선스 하에 배포하였다.(나중에 이것은 "Reactive/RxJava로 재명명되었다.)

- 넷플릭스는 RxJava 위에 Groovy 기반으로 수많은 프로그래밍을 수행했었는데, 이것은 Java에도 사용될 수 있도록 열려 있으며 람다(Lambda)를 사용하면 Java 8과도 매우 잘 들어맞게 되어 있다.

- Reactive Stream에 대한 연결체도 있다. RxJava는 David Karnok의 Reactive 세대 분류 체계에 따르면 2세대 라이브러리에 속한다.

#### Reactor

- Reactor는 Pivotal의 오픈소스팀(이 팀에서 스프링을 만들었다)이 만든 Java 프레임워크이다.

- 이 프레임워크는 Reactive Stream 상에서 직접 빌드하는데, 그래서 브릿지가 필요치 않다.

- Reactor IO 프로젝트는 Netty나 Aeron과 같은 저수준 네트워크 런타임에 대한 래퍼를 제공한다.

- Reactor는 David Karnok의 Reactive 세대 분류 체계에 따르면 4세대 라이브러리에 속한다.


#### Spring Framework 5.0




### 키워드 (내가이해한거 위주로)


- 함수형 프로그래밍
    - filter, map ,reduce

- 리액티브 프로그래밍

    - 비동기, 옵저버, 콜백

- FRP

    - RX (비동기 함수형




## 참고

http://wiki.sys4u.co.kr/pages/viewpage.action?pageId=7766896


https://m.blog.naver.com/PostView.nhn?blogId=jdub7138&logNo=220983291803&proxyReferer=https%3A%2F%2Fwww.google.co.kr%2F

https://gist.github.com/casamia918/93b8db69beb9ee06b92a96b2a234d48e